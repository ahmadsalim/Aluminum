package minsolver;

/* 
 * Kodkod -- Copyright (c) 2005-2007, Emina Torlak
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.StringTokenizer;

import javax.swing.JOptionPane;

import org.sat4j.specs.ContradictionException;
import org.sat4j.specs.IConstr;
import org.sat4j.specs.TimeoutException;
import kodkod.ast.Formula;
import kodkod.ast.Relation;
import kodkod.engine.config.Options;
import minsolver.fol2sat.MinHigherOrderDeclException;
import minsolver.fol2sat.MinTranslation;
import minsolver.fol2sat.MinTranslationLog;
import minsolver.fol2sat.MinTranslator;
import minsolver.fol2sat.MinTrivialFormulaException;
import minsolver.fol2sat.MinUnboundLeafException;
import kodkod.engine.satlab.SATAbortedException;
import kodkod.engine.satlab.SATProver;
import kodkod.engine.satlab.SATSolver;
import kodkod.instance.Bounds;
import kodkod.instance.Instance;
import kodkod.instance.Tuple;
import kodkod.instance.TupleFactory;
import kodkod.instance.TupleSet;
import kodkod.util.ints.IntIterator;
import kodkod.util.ints.IntSet;


/** 
 * A computational engine for solving relational formulae.
 * A {@link kodkod.ast.Formula formula} is solved with respect to given 
 * {@link kodkod.instance.Bounds bounds} and {@link kodkod.engine.config.Options options}.
 * 
 * @specfield options: Options 
 * @author Emina Torlak 
 */
public final class MinSolver {
	private final Options options;
	
	//The iterator that acquires the SAT solver.
	private MinSolutionIterator activeIterator;

	/**
	 * Constructs a new Solver with the default options.
	 * @effects this.options' = new Options()
	 */
	public MinSolver() {
		this.options = new Options();
	}

	/**
	 * Constructs a new Solver with the given options.
	 * @effects this.options' = options
	 * @throws NullPointerException - options = null
	 */
	public MinSolver(Options options) {
		if (options == null)
			throw new NullPointerException();
		this.options = options;
	}

	/**
	 * Returns the Options object used by this Solver
	 * to guide translation of formulas from first-order
	 * logic to cnf.
	 * @return this.options
	 */
	public Options options() {
		return options;
	}
	
	/**
	 * Attempts to satisfy the given formula with respect to the specified bounds, while
	 * minimizing the specified cost function.
	 * If the operation is successful, the method returns a Solution that contains either a minimal-cost
	 * instance of the formula or a proof of unsatisfiability.  The latter is generated iff 
	 * the SAT solver generated by this.options.solver() is a {@link SATProver SATProver} in  addition
	 * to being a {@link kodkod.engine.satlab.SATMinSolver SATMinSolver}.
	 * 
	 * @requires this.options.logTranslation==0 && this.options.solver.minimizer
	 * @return Solution to the formula with respect to the given bounds and cost
	 * @throws NullPointerException - formula = null || bounds = null || cost = null
	 * @throws kodkod.engine.fol2sat.UnboundLeafException - the formula contains an undeclared variable or
	 * a relation not mapped by the given bounds
	 * @throws kodkod.engine.fol2sat.HigherOrderDeclException - the formula contains a higher order declaration that cannot
	 * be skolemized, or it can be skolemized but this.options.skolemize is false.
	 * @throws AbortedException - this solving task was interrupted with a call to Thread.interrupt on this thread
	 * @throws IllegalArgumentException -  some  (formula.^children & Relation) - cost.relations
	 * @throws IllegalStateException - !this.options.solver.minimizer || this.options.logTranslation
	 * @see Solution
	 * @see Options
	 * @see Cost
	 */
/*	public MinSolution solve(Formula formula, Bounds bounds, Cost cost)
			throws MinHigherOrderDeclException, MinUnboundLeafException, MinAbortedException {
		if (options.logTranslation()>0 || !options.solver().minimizer())
			throw new IllegalStateException();
		
		final long startTransl = System.currentTimeMillis();
		try {
			
			final MinTranslation translation = MinTranslator.translate(formula, bounds, options);
			final long endTransl = System.currentTimeMillis();

			final SATMinSolver cnf = (SATMinSolver)translation.cnf();
			for(Relation r : bounds.relations()) {
				IntSet vars = translation.primaryVariables(r);
				if (vars != null) {
					int rcost = cost.edgeCost(r);
					for(IntIterator iter = vars.iterator();  iter.hasNext(); ) {
						cnf.setCost(iter.next(), rcost);
					}
				}
			}
			
			options.reporter().solvingCNF(0, cnf.numberOfVariables(), cnf.numberOfClauses());
			final long startSolve = System.currentTimeMillis();
			final boolean isSat = cnf.solve();
			final long endSolve = System.currentTimeMillis();

			final MinStatistics stats = new MinStatistics(translation, endTransl - startTransl, endSolve - startSolve);
			
			return isSat ? sat(bounds, translation, stats) : unsat(translation, stats);
		} catch (MinTrivialFormulaException trivial) {
			final long endTransl = System.currentTimeMillis();
			return trivial(bounds, trivial, endTransl - startTransl);
		} catch (SATAbortedException sae) {
			throw new MinAbortedException(sae);
		}
	}*/

	/**
	 * Attempts to satisfy the given formula with respect to the specified bounds or
	 * prove the formula's unsatisfiability.
	 * If the operation is successful, the method returns a Solution that contains either
	 * an instance of the formula or an unsatisfiability proof.  Note that an unsatisfiability
	 * proof will be constructed iff this.options specifies the use of a core extracting SATSolver.
	 * Additionally, the CNF variables in the proof can be related back to the nodes in the given formula 
	 * iff this.options has translation logging enabled.  Translation logging also requires that 
	 * there are no subnodes in the given formula that are both syntactically shared and contain free variables.  
	 * 
	 * @return Solution to the formula with respect to the given bounds
	 * @throws NullPointerException - formula = null || bounds = null
	 * @throws kodkod.engine.fol2sat.UnboundLeafException - the formula contains an undeclared variable or
	 * a relation not mapped by the given bounds
	 * @throws kodkod.engine.fol2sat.HigherOrderDeclException - the formula contains a higher order declaration that cannot
	 * be skolemized, or it can be skolemized but this.options.skolemize is false.
	 * @throws AbortedException - this solving task was interrupted with a call to Thread.interrupt on this thread
	 * @see Solution
	 * @see Options
	 * @see Proof
	 */
	public MinSolution solve(Formula formula, Bounds origBounds)
			throws MinHigherOrderDeclException, MinUnboundLeafException, MinAbortedException {
		final long startTransl = System.currentTimeMillis();
		
		try {		
		
			final MinTranslation translation = MinTranslator.translate(formula, origBounds, options);
			final long endTransl = System.currentTimeMillis();

			final SATSolver cnf = translation.cnf();
			
			options.reporter().solvingCNF(translation.numPrimaryVariables(), cnf.numberOfVariables(), cnf.numberOfClauses());
			final long startSolve = System.currentTimeMillis();
			final boolean isSat = cnf.solve();
			final long endSolve = System.currentTimeMillis();

			final MinStatistics stats = new MinStatistics(translation, endTransl - startTransl, endSolve - startSolve);
			return isSat ? sat(origBounds, translation, stats) : unsat(translation, stats);
			
		} catch (MinTrivialFormulaException trivial) {
			final long endTransl = System.currentTimeMillis();
			return trivial(origBounds, trivial, endTransl - startTransl);
		} catch (SATAbortedException sae) {
			throw new MinAbortedException(sae);
		}
	}
	
	/**
	 * Attempts to find all solutions to the given formula with respect to the specified bounds or
	 * to prove the formula's unsatisfiability.
	 * If the operation is successful, the method returns an iterator over n Solution objects. The outcome
	 * of the first n-1 solutions is SAT or trivially SAT, and the outcome of the nth solution is UNSAT
	 * or tirivally  UNSAT.  Note that an unsatisfiability
	 * proof will be constructed for the last solution iff this.options specifies the use of a core extracting SATSolver.
	 * Additionally, the CNF variables in the proof can be related back to the nodes in the given formula 
	 * iff this.options has variable tracking enabled.  Translation logging also requires that 
	 * there are no subnodes in the given formula that are both syntactically shared and contain free variables.  
	 * 
	 * @return an iterator over all the Solutions to the formula with respect to the given bounds
	 * @throws NullPointerException - formula = null || bounds = null
	 * @throws kodkod.engine.fol2sat.UnboundLeafException - the formula contains an undeclared variable or
	 * a relation not mapped by the given bounds
	 * @throws kodkod.engine.fol2sat.HigherOrderDeclException - the formula contains a higher order declaration that cannot
	 * be skolemized, or it can be skolemized but this.options.skolemize is false.
	 * @throws AbortedException - this solving task was interrupted with a call to Thread.interrupt on this thread
	 * @throws IllegalStateException - !this.options.solver().incremental()
	 * @see Solution
	 * @see Options
	 * @see Proof
	 */
	public Iterator<MinSolution> solveAll(final Formula formula, final Bounds origBounds) 
		throws MinHigherOrderDeclException, MinUnboundLeafException, MinAbortedException {
		if (!options.solver().incremental())
			throw new IllegalArgumentException("cannot enumerate solutions without an incremental solver.");
						
		MinSolutionIterator iterator = new MinSolutionIterator(this, formula, origBounds, options);
		
		return iterator;
	}
	
	/**
	 * Augments a model from an iterator with a set of facts aka lifters.
	 * @param formula the original FOL formula.
	 * @param origBounds the bounds.
	 * @param iterator the previous iterator.
	 * @param solution the current solution of the previous iterator being lifted.
	 * @param lifters the facts to augment.
	 * @return a new iterator over the augmented models.
	 * @throws MinHigherOrderDeclException
	 * @throws UnboundLeafException
	 * @throws MinAbortedException
	 */
	//TODO in a refined implementation, we don't need the formula and bound since we have the translation 
	//via previous iterator.
	public MinSolutionIterator lift(final Formula formula, Iterator<MinSolution> prevIterator, 
			Instance lifters)
			throws MinHigherOrderDeclException, MinUnboundLeafException, MinAbortedException, ExplorationException {
		
		if (!options.solver().incremental())
			throw new IllegalArgumentException("cannot enumerate solutions without an incremental solver.");
		
		MinSolutionIterator msiterator = (MinSolutionIterator)prevIterator;
		
		if(msiterator.trivial)
		{
			// Disable augmentation and redirect them to the set of consist. facts (for now):
			JOptionPane.showMessageDialog(null, "The spec given was trivially satisfiable, and so it had only one minimal model (shown),\n"+
			"to which any relational fact in the set of consistent facts may be added without consequence.\n\n"+
					"Explicit exploration is unavailable.");
			return msiterator;
		}
		
		//Lifting is always performed on skolemBounds.
		Bounds skBounds = ((MyReporter)options.reporter()).skolemBounds;
		
		ArrayList<Integer> allLifters = new ArrayList<Integer>();
		
		// Do not use getLastSolution() here: it may be the iterator is empty, in which case it would contain no
		// propositional model, being the UNSAT soln. Instead, use the last *instance* found:
		Map<Relation, TupleSet> solutionTuples = msiterator.lastSatSolutionFound.instance().relationTuples();
		Map<Relation, TupleSet> lifterTuples = lifters.relationTuples();

		//This can be a method!
		for(Relation r : solutionTuples.keySet()){
			TupleSet tuples = solutionTuples.get(r);
			for(Tuple t: tuples){
				int index = MinTwoWayTranslator.getPropVariableForTuple(skBounds, msiterator.getTranslation(), r, t);
				//if there is no primary variables assigned to this relation, continue.
				if(index == -1)
					continue;
				allLifters.add(index);
			}
		}
		
		for(Relation r : lifterTuples.keySet()){
			TupleSet tuples = lifterTuples.get(r);
			if(tuples != null)
				for(Tuple t: tuples){
					if(solutionTuples.get(r).contains(t))
						throw new ExplorationException("The fact " + t + " is already true in the solution.");

					int index = MinTwoWayTranslator.getPropVariableForTuple(skBounds, msiterator.getTranslation(), r, t);					
					//if there is no primary variables assigned to this relation, continue.
					if(index == -1)
						continue;
					
					allLifters.add(index);
				}
		}
		
		MinSolutionIterator iterator = new MinSolutionIterator(this, formula, skBounds, options, allLifters, msiterator);
				
		return iterator;
	}	
	
	/**
	 * Returns the lifters for the current model loaded in the given iterator.
	 * @param iterator the iterator.
	 * @return the lifters tuple relations of an instance.
	 * @throws TimeoutException
	 * @throws ContradictionException
	 */
	public Instance getLifters(Iterator<MinSolution> iterator) throws TimeoutException, ContradictionException{
		MinSolutionIterator theIterator = (MinSolutionIterator)iterator;
				
		if(theIterator.trivial)
		{
			// No translation available to lift. Get the upper bounds - the lower bounds:
			Bounds skBounds = ((MyReporter)options.reporter()).skolemBounds;			
			Instance results = new Instance(skBounds.universe());			
			for(Relation r : skBounds.relations())
			{				
				TupleSet tuples = skBounds.upperBound(r).clone();			
				tuples.removeAll(skBounds.lowerBound(r));							
				results.add(r, tuples);							
			}
			
			//JOptionPane.showMessageDialog(null, "getLifters: "+results);			
			return results;
		}

		// If not trivial, go through the propositional translation
		return MinTwoWayTranslator.translatePropositions(
				theIterator.translation, ((MyReporter)theIterator.options.reporter()).skolemBounds,
				theIterator.mapVarToRelation,
				theIterator.getLifters());
		
	}
	
	/**
	 * Returns a list of lifters for the current model loaded in the given iterator as 
	 * a line separated string.
	 * @param iterator the iterator.
	 * @return returns a list of line separated strings of lifters. If an exception occurs,
	 * it returns an empty string.
	 */    
	public String getLiftersList(Iterator<MinSolution> iterator){
		return getLiftersList(iterator, null);
	}	
	
	/**
	 * Returns a list of lifters for the current model loaded in the given iterator as 
	 * a line separated string.
	 * @param iterator the iterator.
	 * @param dictionary a renaming will be applied on the atoms according to the dictionary.
	 * @return returns a list of line separated strings of lifters. If an exception occurs,
	 * it returns an empty string.
	 */    
	public String getLiftersList(Iterator<MinSolution> iterator, Map<String, String> dictionary){
		String retVal = "";
		MinSolutionIterator miniterator = ((MinSolutionIterator)iterator);
		MinTranslation translation = miniterator.translation;
		
		Bounds bounds = ((MyReporter)options.reporter()).skolemBounds;
		
		//Keeps the pattern of the output when a NEW-INSTANCE is involved. The outputs that have
		//repetitive patterns will be discarded.
		Set<String> uniqeOutputPattern = new LinkedHashSet<String>();
		
		Instance lifters = null;
		
		try{
			lifters = getLifters(iterator);
		}
		catch(Exception e){
			return "";
		}
		
		Map<Relation, TupleSet> lifterTuples = lifters.relationTuples();
		
		//This can be a method!
		for(Relation r : lifterTuples.keySet()){
			TupleSet tuples = lifterTuples.get(r);
			for(Tuple t: tuples){
				if(!miniterator.trivial)
				{
					int index = MinTwoWayTranslator.getPropVariableForTuple(bounds, translation, r, t);
					//if there is no primary variables assigned to this relation, continue.
					if(index == -1)
						continue;
				}

				if(dictionary != null){
			        final StringBuilder ret = new StringBuilder("["); //This section of the code produces t.toString manually:
			        StringBuilder pattern = new StringBuilder("["); //keeps the pattern of the next output.
			        
			        String label = dictionary.get(t.atom(0));
			        if(label != null){
			        	ret.append(label);
				        pattern.append(label);
			        }
			        else{
			        	ret.append("NEW-INSTANCE(" + t.atom(0) + ")");
			        	pattern.append("NEW-INSTANCE"); //For new instances, do not keep the name of the atom
			        }
			        for (int i = 1; i < t.arity(); i++) {
			            ret.append(", ");
			            pattern.append(",");
			            label = dictionary.get(t.atom(i));
			            if(label != null){
			            	ret.append(label);
			            	pattern.append(label);
			            }
			            else{
			            	ret.append("NEW-INSTANCE(" + t.atom(i) + ")");
			            	pattern.append("NEW=INSTANCE");
			            }
			        }
			        ret.append("]");
			        pattern.append("]");
			        if(uniqeOutputPattern.add(r.toString()+ pattern.toString())) //if the pattern is not repetitive
			        	retVal += r.toString() + ret.toString() + "\n";
				} else{
					retVal += r.toString() + t.toString() + "\n";
				}
			}
		}
		
		return retVal;
	}

	/**
	 * Builds a consistent fact that can be used for lifting a model.
	 * @param inputStr the input string
	 * @param iterator the iterator to be lifted by this fact.
	 * @return an object of type Instance containing the lifting fact.
	 */	
	public Instance parseString(String inputStr, Iterator<MinSolution> iterator){
		return parseString(inputStr, iterator, null);
	}	
	
	/**
	 * Builds a consistent fact that can be used for lifting a model.
	 * @param inputStr the input string
	 * @param iterator the iterator to be lifted by this fact.
	 * @param dictionary is used to translate the atoms to their names in Kodkod.
	 * @return an object of type Instance containing the lifting fact.
	 */
	public Instance parseString(String inputStr, Iterator<MinSolution> iterator, Map<String, String> dictionary){
		inputStr = inputStr.trim();
		inputStr = inputStr.replaceAll(" ", "");
		
		String relationName = null;
		int index1 = inputStr.indexOf('[');
		if(index1 == -1)
			return null;
		
		relationName = inputStr.substring(0, index1);

		int index2 = inputStr.indexOf(']');
		if(index2 == -1)
			return null;
		
		StringTokenizer tokenizer = new StringTokenizer(inputStr.substring(index1 + 1, index2), ",");
		
		ArrayList<String> constants = new ArrayList<String>();
		
		while(tokenizer.hasMoreTokens()){
			constants.add(tokenizer.nextToken());
		}

		Bounds bounds = ((MyReporter)options.reporter()).skolemBounds;
		
		Set<Relation> relations = bounds.relations();
		Relation relation = null;
		for(Relation r: relations){
			if(r.name().equals(relationName)){
				relation = r;
				break;
			}
		}
		
		if(relation == null) //Relation does not exist.
			return null;
		
		TupleSet tuples = bounds.upperBound(relation);
		if(tuples == null)
			return null;

		Tuple tuple = null;
		for(Tuple t: tuples){
			boolean found = true;
			for(int i = 0; i < t.arity(); i++){
				if(dictionary != null){
					String label = dictionary.get(constants.get(i));
					if(label != null){ //if the name is in the dictionary
						if(!t.atom(i).toString().equals(label)){
							found = false;
							break;
						}
					}else{
						if(!("NEW-INSTANCE(" + t.atom(i) + ")").toString().equals(constants.get(i))){
								//|| !t.atom(i).toString().equals(constants.get(i))){
							found = false;
							break;
						}
					}
				}
				else {
					if(!t.atom(i).toString().equals(constants.get(i))){
						found = false;
						break;
					}
				}
			}
			if(found == true){
				tuple = t;
				break;
			}
		}
		
		if(tuple == null) //There is no such tuple
			return null;

		Instance retVal = new Instance(bounds.universe());
		retVal.add(relation, bounds.universe().factory().setOf(tuple));
		
		return retVal;
	}
	
	/**
	 * Returns the bounds after skolemization.
	 */
	public Bounds getSkolemBounds(){
		return ((MyReporter)options.reporter()).skolemBounds;
	}
	
	/**
	 * {@inheritDoc}
	 * @see java.lang.Object#toString()
	 */
	public String toString() {
		return options.toString();
	}
	
	/**
	 * Returns the result of solving a sat formula.
	 * @param bounds Bounds with which  solve() was called
	 * @param translation the translation
	 * @param stats translation / solving stats
	 * @return the result of solving a sat formula.
	 */
	private static MinSolution sat(Bounds bounds, MinTranslation translation, MinStatistics stats) {
		final MinSolution sol = MinSolution.satisfiable(stats, padInstance(translation.interpret(), bounds), 0, null);
		translation.cnf().free();
		return sol;
	}

	/**
	 * Returns the result of solving an unsat formula.
	 * @param translation the translation 
	 * @param stats translation / solving stats
	 * @return the result of solving an unsat formula.
	 */
	private static MinSolution unsat(MinTranslation translation, MinStatistics stats) {
		final SATSolver cnf = translation.cnf();
		final MinTranslationLog log = translation.log();
		if (cnf instanceof SATProver && log != null) {
			return MinSolution.unsatisfiable(stats, new MinResolutionBasedProof((SATProver) cnf, log), 0, null);
		} else { // can free memory
			final MinSolution sol = MinSolution.unsatisfiable(stats, null, 0, null);
			cnf.free();
			return sol;
		}
	}
	
	/**
	 * @return the number of primary variables needed to encode the unknown tuples in the given bounds.
	 */
	private static int trivialPrimaries(Bounds bounds) { 
		int prim = 0;
		for(Relation r : bounds.relations()) { 
			prim += bounds.upperBound(r).size() - bounds.lowerBound(r).size();
		}
		return prim;
	}
	
	/**
	 * Returns the result of solving a trivially (un)sat formula.
	 * @param bounds Bounds with which solve()  was called
	 * @param desc TrivialFormulaException thrown as the result of the formula simplifying to a constant
	 * @param translTime translation time
	 * @return the result of solving a trivially (un)sat formula.
	 */
	private static MinSolution trivial(Bounds bounds, MinTrivialFormulaException desc, long translTime) {
		final MinStatistics stats = new MinStatistics(trivialPrimaries(desc.bounds()), 0, 0, translTime, 0);
		if (desc.value().booleanValue()) {
			return MinSolution.triviallySatisfiable(stats, padInstance(toInstance(desc.bounds()), bounds), 0, null);
		} else {
			return MinSolution.triviallyUnsatisfiable(stats, trivialProof(desc.log()), 0, null);
		}
	}
	
	/**
	 * Returns a proof for the trivially unsatisfiable log.formula,
	 * provided that log is non-null.  Otherwise returns null.
	 * @requires log != null => log.formula is trivially unsatisfiable
	 * @return a proof for the trivially unsatisfiable log.formula,
	 * provided that log is non-null.  Otherwise returns null.
	 */
	private static MinProof trivialProof(MinTranslationLog log) {
		return log==null ? null : new MinTrivialProof(log);
	}
	
	/**
	 * "Pads" the argument instance with the mappings that occur in bounds.lowerBound
	 * but not in the instance. 
	 * @requires instance.relations in bounds.relations
	 * @effects instance.relations' = bounds.relations' &&
	 *          instance.tuples' = bounds.lowerBound ++ instance.tuples
	 * @return instance
	 */
	private static Instance padInstance(Instance instance, Bounds bounds) {
		for (Relation r : bounds.relations()) {
			if (!instance.contains(r)) {
				instance.add(r, bounds.lowerBound(r));
			}
		}
		for (IntIterator iter = bounds.ints().iterator(); iter.hasNext();) {
			int i = iter.next();
			instance.add(i, bounds.exactBound(i));
		}
		return instance;
	}

	/**
	 * Creates an instance from the given Bounds.  The instance
	 * is simply the mapping bounds.lowerBound.
	 * @return the instance corresponding to bounds.lowerBound
	 */
	private static Instance toInstance(Bounds bounds) {
		final Instance instance = new Instance(bounds.universe());
		for (Relation r : bounds.relations()) {
			instance.add(r, bounds.lowerBound(r));
		}
		for (IntIterator iter = bounds.ints().iterator(); iter.hasNext();) {
			int i = iter.next();
			instance.add(i, bounds.exactBound(i));
		}
		return instance;
	}
	
	/**
	 * An iterator over all solutions of a model.
	 * @author Emina Torlak
	 */
	static final class MinSolutionIterator implements Iterator<MinSolution> {
		private final Options options;
		private Formula formula;
		
		/**
		 * The original, pre-Skolem bounds passed to Kodkod.
		 * Access the post-Skolem bounds via MyReporter.
		 */
		private Bounds origBounds;
		
		private boolean trivial = false;
		
		private MinTranslation translation;
		private Map<Integer, Relation> mapVarToRelation;
		private long translTime;
		private MinSolution lastSolution;
		
		//the MinSolver instance that creates the iterator.
		private final MinSolver minSolver;
		
		//Modifications for minimal models
		private Boolean sat = null;
		private MinSolution unsatSolution = null;
		
		/** 
		 * Augmentation requires we keep a handle on the last instance found
		 * even if the iterator is now empty (i.e., lastSolution = an unsatisfiable result).
		 */
		MinSolution lastSatSolutionFound = null;
		
		/**
		 * Keeps cone restriction clauses such that the next model from the SATsolver
		 * is not in any of the previous cones.
		 */
		private Set<List<Integer>> coneRestrictionClauses = new HashSet<List<Integer>>();
		/**
		 * Keeps a list of all the constraints that are being taken into account.
		 * Some operations such as getLifters() has to eliminate all the constraints.
		 * Also, when another iterator is using the solver, the constraints from
		 * the current iterator should be removed.
		 */
		private Set<IConstr> coneRestrictionConstraints = new HashSet<IConstr>();

		/**
		 * Keeps a list of all the unit constraints due to a bug in SAT4J that does not
		 * return a handle to remove unit constraints.
		 */
		private Set<Integer> coneRestrictionUnits = new HashSet<Integer>();
		
		/**
		 * The lifters for this iteration.
		 */
		private final int[] lifters;
		
		/**
		 * Constructs a solution iterator for the given formula, bounds, and options.
		 */
		MinSolutionIterator(MinSolver minSolver, Formula formula, Bounds origBounds, Options options) {			
			this(minSolver, formula, origBounds, options, null, null);			
		}

		/**
		 * For debugging
		 */
		long parentHash = 0;
		
		/**
		 * Constructs a solution iterator for the given formula, bounds, options and lifters.
		 * @param formula
		 * @param origBounds
		 * @param options
		 * @param lifters
		 * @param prevIterator
		 */
		
		MinSolutionIterator(MinSolver minSolver, Formula formula, Bounds origBounds, Options options, ArrayList<Integer> lifters, MinSolutionIterator prevIterator) {
			this.minSolver = minSolver;
			this.formula = formula;
			this.origBounds = origBounds;
			this.options = options;
			this.translation = null;
			this.lifters = (lifters == null) ? null : toIntCollection(lifters);					
			
			if(prevIterator != null){  //if lifting on a previous iterator
				this.translation = prevIterator.getTranslation();
				this.mapVarToRelation = prevIterator.mapVarToRelation;		
				this.parentHash = prevIterator.hashCode();
			}
		}
		
		/**
		 * Debugging string.
		 */
		public String toString()
		{
			StringBuffer result = new StringBuffer();
			result.append("Iterator hash code:"+hashCode()+"\n");
			result.append("Iterator parent's hash code:"+parentHash+"\n");
			result.append("Iterator formula:"+formula+"\n");
			result.append("Iterator origBounds:"+origBounds+"\n");
			result.append("Iterator lifters:"+Arrays.toString(lifters)+"\n");
			result.append("Iterator translation's num pri vars:"+translation.numPrimaryVariables()+"\n");
			result.append("Iterator solver's hash code:"+minSolver.hashCode()+"\n");
			result.append("Iterator mapVarToRelation:"+mapVarToRelation+"\n");
			return result.toString();
		}
		
		/**
		 * Returns true if there is another solution.
		 * @see java.util.Iterator#hasNext()
		 */
		public boolean hasNext() {
			// Can no longer set formula=null; instead use unsatSolution (reversed)
			return (unsatSolution == null);
		}
		
		/**
		 * Solves translation.cnf and adds the negation of the
		 * found model to the set of clauses.
		 * @requires this.translation != null
		 * @effects this.translation.cnf is modified to eliminate
		 * the  current solution from the set of possible solutions
		 * @return current solution
		 */
		private MinSolution nonTrivialSolution() {						
			try {
				final MinSATSolver internalSolver = translation.cnf();
				
				try{
					// If all the previous constraints have been removed by another operation,
					// add them again.
					if(coneRestrictionConstraints.isEmpty()){
						addAllClauses();
					}
				}
				catch(ContradictionException e){
					JOptionPane.showMessageDialog(null, "CONTRADICTION exception in nonTrivialSolution()");
				}
				
				options.reporter().solvingCNF(translation.numPrimaryVariables(), internalSolver.numberOfVariables(), internalSolver.numberOfClauses());				
				final long startSolve = System.currentTimeMillis();				
				boolean isSat = false;
				boolean gotNonMinimal;
				do
				{
					gotNonMinimal = false;					
					//try
					//{
						isSat = solve();
					//} catch(NotMinimalModelException e)
					//{
					//	isSat = true; // Must have gotten SOME model; need to cone restrict.
					//	gotNonMinimal = true;
					//}
					
					//JOptionPane.showMessageDialog(null, "Solve() got:"+isSat+";"+gotNonMinimal);
					
					// If a model found, add constraints to forbid its cone.
					if(isSat)
					{												
						final int primary = translation.numPrimaryVariables();					
						final ArrayList<Integer> notModel = new ArrayList<Integer>();		
						
						// Negate this model's positive diagram. 
						// We will use this disjunctively for "cone-restriction": preventing models 
						// (or any of their supermodels) from occuring again.
						for(int i = 1; i <= primary; i++){
							if(internalSolver.valueOf(i)){
								notModel.add(-i);
							}
						}
																		
						//JOptionPane.showMessageDialog(null, "Syms: "+translation.symmetries+
						//		"\nPerms: "+translation.permutations+
						//		"\nnotModel="+notModel);
						
						try{	
							//JOptionPane.showMessageDialog(null, translation.permutations);
							// Add the cone restriction for this model:
							addConeRestriction(notModel, internalSolver);
							// Add the cone restriction for all (safe) adjacent transpositions: 
							addPermConeRestrictions(notModel, internalSolver);
						}
						catch(ContradictionException e) {
							// This iterator is now out of models. Either we just gave the empty model,
							// or a cone restriction clause has resulted in a contradiction. So make sure
							// that this iterator never yields a model again:
							JOptionPane.showMessageDialog(null, "Contradiction; out of models. Augmentation will be disabled.");
							final long endSolveU = System.currentTimeMillis();				
							final MinStatistics statsU = new MinStatistics(translation, translTime, endSolveU - startSolve);
							unsatSolution = unsat(translation, statsU);							
						}
					} // end constraints to forbid current cone									
					
				} while(gotNonMinimal && isSat);
				
				
				/////////////////////////////////////////////
				// Found a minimal model (or unsat)
				
				final long endSolve = System.currentTimeMillis();				
				final MinStatistics stats = new MinStatistics(translation, translTime, endSolve - startSolve);
				if (isSat) {
					int[] propositionalModel = translation.cnf().getLastModel().clone();
					// extract the current solution; can't use the sat(..) method because it frees the sat solver
					final MinSolution sol = MinSolution.satisfiable(stats, padInstance(translation.interpret(), origBounds), 
							((MyReporter)options.reporter()).getIterations(), propositionalModel);
					return sol;
				} else {
					unsatSolution = unsat(translation, stats); 
					return unsatSolution;
				}
			} catch (SATAbortedException sae) {
				throw new MinAbortedException(sae);
			}
		}
		
		/**
		 * Add a clause for this negated positive-diagram.
		 * 
		 * @param notModel
		 * @param internalSolver
		 * @throws ContradictionException
		 */
		private void addConeRestriction(List<Integer> notModel, MinSATSolver internalSolver)
				throws ContradictionException
		{						
			if(notModel.size() == 1)
			{
				// No risk of adding duplicates; it's just a set.
				coneRestrictionUnits.add(notModel.get(0));
			}
			else
			{				
				// Avoid adding duplicate clauses to the *SAT SOLVER*. Adding duplicate 
				// clauses ought to be idempotent, but it is not: the same IConstr
				// is returned, and removeConstraint will only end up removing the 
				// *FIRST* such clause, not all of them. So never add duplicates!
				if(coneRestrictionClauses.contains(notModel))
					return;								
				
				// (This will be called if notModel.size() ==0, triggering the exception.)							
				coneRestrictionConstraints.add(internalSolver.addConstraint(toIntCollection(notModel)));
				coneRestrictionClauses.add(notModel);
								
			}			
		}
		
		/**
		 * Add cone-restriction clauses for the broken symmetries (i.e., the symmetries for which
		 * Kodkod produces a symmetry-breaking predicate) of this negated positive-diagram.
		 * 
		 * @param notModel
		 * @param internalSolver
		 * @throws ContradictionException
		 */
		@SuppressWarnings("unused")
		private void addPermConeRestrictions(ArrayList<Integer> notModel, MinSATSolver internalSolver) 
				throws ContradictionException
		{			
			// the CALLER is responsible for adding the original restriction clause:
			//addConeRestriction(notModel, internalSolver);
			
			int permCounter = 0;
			for(Map<Integer, Integer> aPerm : translation.permutations)
			{
				// For safety. Note that this is a *completely different use*
				// of the symmetry-breaking option. Here it means the number of
				// permuted cone-restriction clauses. In the SBP, it limits
				// the *length* of each sub-formula.
				if(permCounter >= options.symmetryBreaking())
					break;				
				
				// Apply this permutation and add the permuted C.R. clause. The permutation
				// is assumed to be complete. I.e., if 2->3, then 3->x for some x. In our
				// case, the permutations are actually length 2 (2->3 then 3->2). 
				List<Integer> permNotModel = permuteNegatedPositiveDiagram(notModel, aPerm);				
				addConeRestriction(permNotModel, internalSolver);								
				permCounter++;

				//JOptionPane.showMessageDialog(null, permCounter+" Added restriction. notModel="+notModel+"\naPerm="+aPerm+"\npermNotModel="+permNotModel);				
			}			
		}

		/**
		 * Given a negated positive diagram, apply a permutation to it.
		 * 
		 * @param notModel
		 * @param aPerm
		 * @return
		 */
		private List<Integer> permuteNegatedPositiveDiagram(ArrayList<Integer> notModel,
				Map<Integer, Integer> aPerm) 
		{
			List<Integer> result = new ArrayList<Integer>(notModel.size());
			for(Integer aLiteral : notModel)
			{
				if(aLiteral > 0 && aPerm.containsKey(aLiteral))
					result.add(aPerm.get(aLiteral));
				else if(aLiteral < 0 && aPerm.containsKey(aLiteral*-1))
					result.add(aPerm.get(aLiteral*-1)*-1);
				else
					result.add(aLiteral);					
			}
			
			return result;
		}

		/**
		 * Packages the information from the given trivial formula exception
		 * into a solution and returns it.  If the formula is satisfiable, 
		 * this.formula and this.bounds are modified to eliminate the current
		 * trivial solution from the set of possible solutions.
		 * @requires this.translation = null
		 * @effects this.formula and this.bounds are modified to eliminate the current
		 * trivial solution from the set of possible solutions.
		 * @return current solution
		 */
		private MinSolution trivialSolution(MinTrivialFormulaException tfe) {
			final MinStatistics stats = new MinStatistics(0, 0, 0, translTime, 0);
			
			// Heavily modified from original. When presenting only minimal models,
			// only the first trivial solution needs to be presented: the lower-bounds
			// give a unique (up to isomorphism) minimal model. So return it, but do
			// not prepare other solutions.
			
			trivial = true;
			
			if (tfe.value().booleanValue()) {				
				final Bounds translBounds = tfe.bounds();
				final Instance trivialInstance = padInstance(toInstance(translBounds), origBounds);
				final MinSolution sol = MinSolution.triviallySatisfiable(stats, trivialInstance, 0, null);
				
				// Disallow future solving via this iterator.
				unsatSolution = MinSolution.triviallyUnsatisfiable(stats, null, 0, null);
				return sol;
			} else {
				unsatSolution = MinSolution.triviallyUnsatisfiable(stats, trivialProof(tfe.log()), 0, null);
				return unsatSolution;
			}
		}
		/**
		 * Returns the next solution if any.
		 * @see java.util.Iterator#next()
		 */
		public MinSolution next() {
			if (!hasNext()) return unsatSolution;
			
			claimSATSolver();

			if (translation==null) {
				try {
					translTime = System.currentTimeMillis();
					translation = MinTranslator.translate(formula, origBounds, options);
					translTime = System.currentTimeMillis() - translTime;
					//We use this data structure for translation:
					//mapVarToRelation = MinTwoWayTranslator.buildVarToRelationMap(translation, bounds);
					mapVarToRelation = MinTwoWayTranslator.buildVarToRelationMap(translation, 
							((MyReporter)options.reporter()).skolemBounds);
					
					// Print the translation (DEBUG ONLY!)
					//String transStr = MinTwoWayTranslator.printTranslation(translation, 
					//		((MyReporter)options.reporter()).skolemBounds,
					//		mapVarToRelation);
					//JOptionPane.showMessageDialog(null, transStr);
					
					setLastSolution(nonTrivialSolution());
				} catch (MinTrivialFormulaException tfe) {
					translTime = System.currentTimeMillis() - translTime;
					setLastSolution(trivialSolution(tfe));
				} 
			} else {
				setLastSolution(nonTrivialSolution());
			}						
			
			return getLastSolution();
		}

		/**
		 * Prepares the solver to be used by the current iterator.
		 */
		private void claimSATSolver() {
			if(minSolver.activeIterator != null && minSolver.activeIterator != this){
				//Remove all the constraints of the previous active iterator.
				minSolver.activeIterator.removeAllConstraints();
				//Add the constraints of the current iterator.
				try{
					if(coneRestrictionConstraints.isEmpty())
						addAllClauses();
				}
				catch(ContradictionException e){
					JOptionPane.showMessageDialog(null, "CONTRADICTION exception in claimSATSolver()");
				}
			}
			//Set the activeIterator
			minSolver.activeIterator = this;
			
			//Deactivate SBP if the iterator is augmented by some fact.
			if(translation != null){
				if(isAugmented()) //if the iterator is an augmentation
					((MinSATSolver)translation.cnf()).deactivateSBP();
				else
					((MinSATSolver)translation.cnf()).activateSBP();
			}
		}		
		
		/**
		 * @see java.util.Iterator#remove()
		 */
		public void remove() {
			throw new UnsupportedOperationException();
		}
		
		/**
		 * Prepares a minimal model.
		 * @return true if there is a next solution; otherwise, false.
		 * @throws NotMinimalModelException 
		 */
		private boolean solve() {
			// In case this iterator should never return a model again:
			if(!hasNext()) return false;
			
			try{
				Set<Integer> allUnits = new HashSet<Integer>();
				allUnits.addAll(toSet(lifters));
				allUnits.addAll(coneRestrictionUnits);
				
				if(allUnits.size() == 0)
					sat = Boolean.valueOf(translation.cnf().solve());
				else
					sat = Boolean.valueOf(translation.cnf().solve(toIntCollection(allUnits)));
		
				//JOptionPane.showMessageDialog(null, sat+" "+allUnits.size());
				
				if(sat)
				{	
					try{
						minimize();
					}
					catch(ContradictionException e)
					{
						JOptionPane.showMessageDialog(null, "CONTRADICTION exception in minimize() call");
					}
				}								
				
				return sat;
			} catch (org.sat4j.specs.TimeoutException e) {
				throw new RuntimeException("timed out");
			}
		}

		/**
		 * Minimizes the model in the SAT solver.
		 * @throws TimeoutException
		 * @throws ContradictionException
		 * @throws NotMinimalModelException 
		 */
		private void minimize() throws TimeoutException, ContradictionException
		{
			
			// Assumption: Have already found a model at this point!							
			
			// This keeps constraints to be removed from the solver
			// after finding the next model.
			Set<IConstr> constraints = new HashSet<IConstr>();
			
			// All the unit clauses being passed to the solver as assumptions.
			Set<Integer> unitClauses = toSet(lifters);						
			
			// Add all coneRestrictionUnits
			for(Integer value: coneRestrictionUnits)
				unitClauses.add(value);
			
			MinSATSolver theSolver = ((MinSATSolver)translation.cnf());						
			
			theSolver.deactivateSBP();
			
			int iterationCounter = 1;						
			
			do
			{
				// Given that candidate for minimal-model, try to make something smaller.
				// add: disjunction of negations of all positive literals in M (constraint)
				// add: all negative literals as unit clauses
				
				// An array of the next constraint being added.
				List<Integer> loseSomethingPositive = new ArrayList<Integer>();
				
				int numPrimaryVariables = translation.numPrimaryVariables();
					
				for(int i = 1; i <= numPrimaryVariables; i++){
					if(theSolver.valueOf(i) == true)
						loseSomethingPositive.add(-i);
					else // don't set anything curr. negative to positive.
						unitClauses.add(-i);
				}
				
				if(loseSomethingPositive.size() == 0)
				{
					// We have minimized down to the empty model. 
					// Avoid calling the final SAT (would be adding the empty clause)
					break;
				}
				if(loseSomethingPositive.size() == 1)
				{
					// We have only one relational fact that can possibly be removed.
					unitClauses.add(loseSomethingPositive.get(0));
				}
				else
				{
					constraints.add(theSolver.addConstraint(toIntCollection(loseSomethingPositive)));
				}
				
				iterationCounter++;
			}
			while(Boolean.valueOf(theSolver.solve(toIntCollection(unitClauses))));
							
			((MyReporter)options.reporter()).setIterations(iterationCounter);
						
			if(!isAugmented()) //if the iterator is NOT an augmentation, activate SBP.
				theSolver.activateSBP();
			
//			JOptionPane.showMessageDialog(null, Arrays.toString(Arrays.copyOf(theSolver.getLastModel(), translation.numPrimaryVariables())));
					
			// Remove all the (non-unit) loseSomethingPositive constraints we just added from the solver:
			Iterator<IConstr> it = constraints.iterator();
			while(it.hasNext()){
				theSolver.removeConstraint(it.next());		
			}
			
			// Do NOT add a constraint here to force the solver out of this cone. 
			// Do that in the next solve() call. We want to leave open the possibility
			// of landing in this cone again to support lifting/exporation!		
		}

		
		/**
		 * Minimizes the model in the SAT solver.
		 * @throws TimeoutException
		 * @throws ContradictionException
		 * @throws NotMinimalModelException 
		 */
/*		private void minimizeWithDiscard() throws TimeoutException, ContradictionException, NotMinimalModelException{
			
			// Assumption: Have already found a model at this point!
					
			
			// This keeps constraints to be removed from the solver
			// after finding the next model.
			Set<IConstr> constraints = new HashSet<IConstr>();
			
			// All the unit clauses being passed to the solver as assumptions.
			Set<Integer> unitClauses = toSet(lifters);
			
			// Add all coneRestrictionUnits
			for(Integer value: coneRestrictionUnits)
				unitClauses.add(value);
			
			MinSATSolver theSolver = ((MinSATSolver)translation.cnf());
			
			boolean needToCheck = true;
			
			//COMMENT: With the current configuration (SB = OFF) for the augmented iterators, we don't need to
			//check for minimality.
			if(isAugmented()) //if the iterator is an augmentation
				needToCheck = false;
			
			
			int iterationCounter = 1;						
			
			do
			{
				// Given that candidate for minimal-model, try to make something smaller.
				// add: disjunction of negations of all positive literals in M (constraint)
				// add: all negative literals as unit clauses
				
				// An array of the next constraint being added.
				List<Integer> loseSomethingPositive = new ArrayList<Integer>();
				
				int numPrimaryVariables = translation.numPrimaryVariables();
					
				for(int i = 1; i <= numPrimaryVariables; i++){
					if(theSolver.valueOf(i) == true)
						loseSomethingPositive.add(-i);
					else // don't set anything curr. negative to positive.
						unitClauses.add(-i);
				}
				
				if(loseSomethingPositive.size() == 0)
				{
					// We have minimized down to the empty model. No need to
					// check to see if it is minimal in the original category!
					// Also: avoid calling the final SAT (would be a Contradiction).
					needToCheck = false;
					break;
				}
				if(loseSomethingPositive.size() == 1)
				{
					// We have only one relational fact that can possibly be removed.
					unitClauses.add(loseSomethingPositive.get(0));
				}
				else
				{
					constraints.add(theSolver.addConstraint(toIntCollection(loseSomethingPositive)));
				}
				
				iterationCounter++;
			}
			while(Boolean.valueOf(theSolver.solve(toIntCollection(unitClauses))));
					
			boolean badSolution = false;
			// Don't check for true minimality if we already have the empty model.
			if(needToCheck)
			{
				//////////////////////////////////
				// Deactivate SBP. We need to see if this minimal candidate
				// is truly minimal in the original category (NOT the category
				// that includes the SBP.)			
				//JOptionPane.showMessageDialog(null, theSolver.internalNumConstraints());
				theSolver.deactivateSBP();
				// Unsatisfiable w/ SBP active (or we wouldn't be here). Try without:
				badSolution = theSolver.solve(toIntCollection(unitClauses), false);							
				// Re-activate SBP 
				//JOptionPane.showMessageDialog(null, theSolver.internalNumConstraints());
				theSolver.activateSBP();
				//JOptionPane.showMessageDialog(null, theSolver.internalNumConstraints());
				//////////////////////////////////
			}
			
			((MyReporter)options.reporter()).setIterations(iterationCounter);
			
			//internalMinimalCandidatesFoundCounter++;
			
//			JOptionPane.showMessageDialog(null, Arrays.toString(Arrays.copyOf(theSolver.getLastModel(), translation.numPrimaryVariables())));
					
			// Remove all the (non-unit) loseSomethingPositive constraints we just added from the solver:
			Iterator<IConstr> it = constraints.iterator();
			while(it.hasNext()){
				theSolver.removeConstraint(it.next());		
			}
			
			// Do NOT add a constraint here to force the solver out of this cone. 
			// Do that in the next solve() call. We want to leave open the possibility
			// of landing in this cone again to support lifting/exporation!		
			
			// Finally, if this isn't a real solution, throw an exception to warn the caller.
			if(badSolution)
				throw new NotMinimalModelException();
		}*/

		
		/*class NotMinimalModelException extends Exception
		{			
			private static final long serialVersionUID = 1L;

			NotMinimalModelException()
			{
				
			}
		}*/
		
		
		/**
		 * Computes all the lifters for the current model loaded in the solver.
		 * @return
		 * @throws TimeoutException
		 * @throws ContradictionException
		 */
		public int[] getLifters() throws TimeoutException, ContradictionException
		{			
			assert(!trivial);
			
			MinSATSolver solver = (MinSATSolver)translation.cnf();								
			Set<Integer> wantToAdd = new HashSet<Integer>();
			ArrayList<Integer> retVal = new ArrayList<Integer>();
			List<Integer> preservedFacts = new ArrayList<Integer>();
			
			//TODO claimSATSolver does not have to fill all the clauses in here.
			claimSATSolver();
			removeAllConstraints();		
			
			// Always deactivate SBP before searching for augmentations
			solver.deactivateSBP();
						
			// preservedFacts are the positive literals that define the "cone" we are in.
			// wantToAdd are the negative (turned positive) literals we want to check for in the cone.

			int numPrimaryVariables = translation.numPrimaryVariables();
			
			// Do not reference lastSolution here. lastSolution will hold an unsatisfiable
			// Solution result if the iterator is empty. Instead, keep the last instance found:					
			int[] lastPropositionalModelReturned = lastSatSolutionFound.getPropositionalModel();
			
			
			for(int i = 1; i <= numPrimaryVariables; i++){
				if(lastPropositionalModelReturned[i - 1] > 0)
					preservedFacts.add(i);
				else
					wantToAdd.add(i);
			}					
			
			boolean wasSatisfiable = false;
			List<Integer> unitClauses = new ArrayList<Integer>(preservedFacts);
								
			//JOptionPane.showMessageDialog(null, wantToAdd+"\n"+preservedFacts);
			
			// Loop while (a) there are facts left to find and (b) still satisfiable.
			do
			{
				// Add a disjunction for the current set of literals we want to find:
				IConstr removeWTA = null;
				//System.out.println("Adding WTA: "+wantToAdd);
				if(wantToAdd.size() > 1)
				{
					removeWTA = solver.addConstraint(toIntCollection(wantToAdd));
				}
				else
				{
					for(Integer onlyOne : wantToAdd)
						unitClauses.add(onlyOne);
				}
				
				wasSatisfiable = solver.solve(toIntCollection(unitClauses));		
				
				//JOptionPane.showMessageDialog(null, "sat="+wasSatisfiable+"; unitClauses="+unitClauses);

				
				if(wasSatisfiable)
				{
					
					//System.out.println("Model found was: "+Arrays.toString(tempModel));
					Set<Integer> foundLifters = new HashSet<Integer>(); // avoid concurrentmodificationexception
					for(Integer toAdd : wantToAdd)
					{
						// The -1 is because the model is an array (start = 0) 
						// yet our variables start=1
						if(solver.valueOf(toAdd))
						{
							foundLifters.add(toAdd);
							retVal.add(toAdd);
						}
					}

					wantToAdd.removeAll(foundLifters);
				}	
				
				// Remove the targets for this iteration (needed to keep the shared solver clean)
				if(removeWTA != null)
					solver.removeConstraint(removeWTA);
				
			}
			while(wantToAdd.size() > 0 && wasSatisfiable);
			
			// If this is an un-augmented iterator, re-activate symmetry-breaking
			// (Or else the next models would not benefit from SB.)
			if(!isAugmented())
				solver.activateSBP();						
			
			return toIntCollection(retVal);
		}
		
		/**
		 * Returns the translation for this iterator.
		 * @return the translation.
		 */
		public MinTranslation getTranslation(){
			return translation;
		}
		
		/**
		 * Returns the last solution of the iterator.
		 * @return the last solution.
		 */
		private MinSolution getLastSolution(){
			return lastSolution;
		}
		
		/**
		 * Always use this function to update lastSolution.
		 * Otherwise the last prop. model will not be saved.
		 */
		private void setLastSolution(MinSolution last) {			
			this.lastSolution = last;
			if(last.instance() != null)
			{
				this.lastSatSolutionFound = last;
			}
		}
		
		/**
		 * Returns true if the iterator is an augmentation and returns false otherwise.
		 */
		private boolean isAugmented(){
			return lifters != null && lifters.length > 0;
		}
		
		//Helpers:
		/**
		 * Considers all the constraints.
		 * @throws ContradictionException
		 */
		private void addAllClauses() throws ContradictionException{
			for(List<Integer> list: coneRestrictionClauses){
				coneRestrictionConstraints.add(((MinSATSolver)translation.cnf()).addConstraint(toIntCollection(list)));					
			}
		}
		
		/**
		 * Removes all the cone restriction constraints of this iterator.
		 */
		private void removeAllConstraints(){
			Iterator<IConstr> it = coneRestrictionConstraints.iterator();
			while(it.hasNext()){
				IConstr temp = it.next();
				translation.cnf().removeConstraint(temp);
				it.remove();
			}
		}		
		
		static int[] toIntCollection(Collection<Integer> integers)
		{
		    int[] ret = new int[integers.size()];
		    int iIndex = 0;
		    for(Integer anInt : integers)
		    {
		        ret[iIndex] = anInt;
		    	iIndex++;	    	
		    }
		    return ret;
		}
		
		/**
		 * Converts a list of integers to an ArrayList.
		 * @param list the list.
		 * @return the ArrayList containing the elements of list.
		 */
		private Set<Integer> toSet(int[] list){
			Set<Integer> retVal = new HashSet<Integer>();
			if(list != null){
				for(int i = 0; i < list.length; i++){
					retVal.add(list[i]);
				}
			}
			
			return retVal;
		}
	}
	
	/**
	 * Handles the translation of propositional elements to relational facts and vice versa.
	 * Caution: Pass the skolem bounds here.
	 * @author Salman
	 *
	 */
	public static class MinTwoWayTranslator{
		
		private static Map<Integer, Relation> buildVarToRelationMap(
				MinTranslation translation, Bounds aBounds){
			Map<Integer, Relation> mapVarToRelation = new HashMap<Integer, Relation>(); 
			for(Relation r : aBounds.relations())
			{
				IntSet varsForThisRelation = translation.primaryVariables(r);
				
				//if there is no primary variable for this relation, continue:
				if(varsForThisRelation == null)
					continue;
				
				IntIterator itVarsForThis = varsForThisRelation.iterator();
				while(itVarsForThis.hasNext())
				{
					mapVarToRelation.put(itVarsForThis.next(), r);
				}
					
			}
			
			return mapVarToRelation;
		}
		
		/**
		 * Used for debugging purposes. Print the bijection between propositional
		 * variables and relational facts as a string.
		 * @param translation
		 * @param aBounds
		 * @param mapVarToRelation
		 * @return
		 */
		@SuppressWarnings("unused")
		private static String printTranslation(MinTranslation translation, Bounds aBounds,
				Map<Integer, Relation> mapVarToRelation)
		{
			String outs="";
			
			// Now that we have the mapping from var --> its relation, we can find the tuple:		
			for(int theVar = 1; theVar <= translation.numPrimaryVariables(); theVar++)
			{					
				Relation myRelation = mapVarToRelation.get(theVar);
				
				IntSet s = translation.primaryVariables(myRelation);
				
				Tuple myTuple = getTupleForPropVariable(
							aBounds, translation, s, myRelation, theVar);
									
				outs += (theVar+": "+myTuple+" "+myRelation+" | ");
				if(theVar % 4 == 0)
					outs += "\n";
			}
			
			return outs;				
		}

		
		/**
		 * Converts a set of primary propositional variables into set of relational expressions.
		 * @param translation the translation.
		 * @param aBounds the bounds.
		 * @param theVars a VectInt of the variables to convert.
		 * @return
		 */
		private static Instance translatePropositions(MinTranslation translation, Bounds aBounds,
				Map<Integer, Relation> mapVarToRelation, int[] theVars)
		{
			// Populate an empty instance over the universe we're using:
			Instance result = new Instance(aBounds.universe());

			// Now that we have the mapping from var --> its relation, we can find the tuple:		
			for(int i = 0; i < theVars.length; i++)
			{	
				int theVar = theVars[i];
				Relation myRelation = mapVarToRelation.get(theVar);
				
				IntSet s = translation.primaryVariables(myRelation);
				
				Tuple myTuple = getTupleForPropVariable(
							aBounds, translation, s, myRelation, theVar);
					
				// .add here is actually .set -- it overwrites what is already in the relation.
				// So we CANNOT just do:			
				//result.add(myRelation, bounds.universe().factory().setOf(myTuple));
				
				TupleSet currentContents = result.tuples(myRelation);
				TupleSet theContents = aBounds.universe().factory().setOf(myTuple);
				if(currentContents != null) // returns null instead of empty set!!
					theContents.addAll(currentContents); 
				
				result.add(myRelation, theContents);
			}
			
			// Set<RelationalFact> would be better than Instance. But for now use Instance
			
			// Return an instance (should not be interpreted as a model of the qry!!) that contains
			// only those relational facts indicated by theVars
			return result;				
		}

		
		private static Tuple getTupleForPropVariable(Bounds aBounds, MinTranslation theTranslation, IntSet s, Relation r, int theVar)
		//throws MInternalNoBoundsException
		{
			// The relation's upper bound has a list of tuple indices. The "index" variable below is an index
			// into that list of indices. (If our upper bound was _everything_, would be no need to de-reference.)
	        int minVarForR = s.min();
			
			// Compute index: (variable - minvariable) of this relation's variables 
	        int index = theVar - minVarForR;
	        
	        // OPT: How slow is this? May want to cache...
	        int[] arr = aBounds.upperBound(r).indexView().toArray();
	        
	        TupleFactory factory = aBounds.universe().factory();   
	        Tuple tup = factory.tuple(r.arity(), arr[index]);  

	        //MCommunicator.writeToLog("\ngetTupleForPropVariable: thisTuple="+tup+" for "+theVar+". Relation had vars: "+s+" and the offset was "+minVarForR+
	        //		"leaving index="+index+". Upper bound indexview: "+Arrays.toString(arr)+
	        //		"\nThe de-referenced tuple index is: "+arr[index]);

	        return tup;
		}
		
		private static int getPropVariableForTuple(Bounds aBounds, MinTranslation translation, Relation r, Tuple tuple){
			IntSet s = translation.primaryVariables(r);

			//if there is no primary variable for this relation, return -1
			if(s == null)
				return -1;
			
			TupleSet upperBound = aBounds.upperBound(r);
			
			if(upperBound == null)
				return -1;
			
			int[] arr = upperBound.indexView().toArray();

			
	        TupleFactory factory = aBounds.universe().factory();
	        
	        int index = -1;
	        //Not the best way of doing this!
	        for(int i = 0; i < arr.length; i++){
	        	if(tuple.equals(factory.tuple(r.arity(), arr[i])))
	        		index = i;
	        }
	        
	        if(index == -1)
	        	return -1;
	        
			return s.min() + index;//s.min() + tuple.index();
		}
	}
	
}
